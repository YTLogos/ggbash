% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggbash.R
\name{ggbash}
\alias{ggbash}
\title{execute a specified ggbash command}
\usage{
ggbash(ggbash_symbols = "", clipboard = NULL, show_warn = TRUE,
  as_string = FALSE)
}
\arguments{
\item{ggbash_symbols}{Non-evaluated R symbols or
a character representing ggbash commands.
If no ggbash_symbols are specified,
enter into an interactive ggbash session.}

\item{clipboard}{Default is NULL.
If non-null, copy the resulted string to clipboard.}

\item{show_warn}{If ambiguously matched, display warning. Default is TRUE.}

\item{as_string}{Return a string instead of a ggplot2 object.
Default is FALSE.}
}
\description{
\code{ggbash()} can be used as follows:
1. ggbash() : with no argument (enter into an interactive ggbash session)
2. ggbash("gg mtcars +  point mpg cyl") : with a character argument
3. ggbash( gg(mtcars) + point(mpg,cyl)) : with ggbash commands and a dataset
4. mtcars %>% ggbash(gg() + point(mpg,cyl)) : dataset piped from dplyr/tidyr
}
\details{
In 1 and 2 cases, parentheses and commas are optional in ggbash commands,
whereas 3 and 4 can only interpret commands with parentheses and commas
because of R's default token constraints.

ggbash features partial match for the following elements:
1. \code{ggplot()} function (any of ggplot(), gg() and g() works)
2. geom names (geom_point can be specified by \code{point} or even \code{p})
3. aesthetics names (\code{size} by \code{sz},
                     \code{color} by \code{col} or \code{c} )
4. column names (prefix match only, no fuzzy match. When ambiguous,
                 the column with the smallest column index is used)
5. theme element names (\code{legend.text} by \code{l.txt},
                        \code{axis.title.x} by \code{a.ttl.x})
}
\examples{
\dontrun{

# Case 1: ggbash() with no argument

ggbash() # ggbash() enters into an interactive ggbash session

# Case 2: with a character arugment

## parentheses and commas become optional

ggbash("gg iris  + point Sepal.W  Sepal.L  color=Species ")
ggbash("gg iris  + point Sepal.W, Sepal.L, color=Species ")
ggbash("gg(iris) + point(Sepal.W, Sepal.L, color=Species)")

## all of the above work


# Case 3: with a short-ggplot2 command

## sm: geom_smooth
ggbash(gg(iris, Sepal.W, Sepal.L, c=Sp) + point + sm(method="lm", se=FALSE)
       + theme(a.txt(sz=25, face="bold"), l.pos("bottom")) )

## if you prefer more ggplot2-compliant syntax
ggbash(ggplot(iris, Sepal.Width, Sepal.Length, colour = Species) +
       geom_point() + geom_smooth(method = "lm", se = FALSE) +
       theme(axis.text(size=25, face="bold"), legend.position("bottom")) )

## or if you prefer an extreme short syntax
ggbash(g(iris, Sepal.W, S, c=Sp) + p + sm(mth="lm", se=FALSE)
       + theme(a.tx(s=25, f="bold"), l.pos("bottom")))

## S ambiguously matches to Sepal.Length, Sepal.Width, Species.
## Since the Sepal.Length has the smallest column index, it's selected


# Case 4: dataset piped from dplyr/tidyr

iris \%>\%
    mutate(my_long_descriptive_column_name = Sepal.Width,
           other_useful_informative_name = Sepal.Length) \%>\%
    ggbash(gg() + point(my, other))

}

}

